//! Project scaffolding (directory and file generation).

use crate::error::CwaResult;
use crate::task;
use std::path::Path;
use tokio::fs;

/// Create a new CWA project with full directory structure.
pub async fn create_project(target_dir: &Path, name: &str) -> CwaResult<()> {
    // Create directory structure
    create_directories(target_dir).await?;

    // Create initial files
    create_claude_md(target_dir, name).await?;
    create_mcp_json(target_dir).await?;
    create_constitution(target_dir, name).await?;
    create_agent_templates(target_dir).await?;
    create_command_templates(target_dir).await?;
    create_rule_templates(target_dir).await?;
    create_skill_templates(target_dir).await?;
    create_hooks_json(target_dir).await?;
    create_docker_infrastructure(target_dir).await?;

    // Initialize database
    let db_path = target_dir.join(".cwa/cwa.db");
    let pool = cwa_db::init_pool(&db_path)?;

    // Create project record
    let project = crate::project::create_project(&pool, name, None)?;

    // Update constitution path
    let constitution_path = target_dir.join(".cwa/constitution.md");
    crate::project::set_constitution_path(&pool, &project.id, constitution_path.to_str().unwrap())?;

    // Initialize Kanban columns
    task::init_kanban_columns(&pool, &project.id)?;

    Ok(())
}

/// Create all required directories.
async fn create_directories(target_dir: &Path) -> CwaResult<()> {
    let dirs = [
        ".cwa",
        ".cwa/specs",
        ".cwa/domain",
        ".cwa/decisions",
        ".cwa/analyses",
        ".cwa/sessions",
        ".cwa/docker",
        ".cwa/docker/scripts",
        ".claude",
        ".claude/agents",
        ".claude/commands",
        ".claude/rules",
        ".claude/skills",
        ".claude/skills/workflow-kickoff",
        ".claude/skills/refactor-safe",
        "docs",
    ];

    for dir in dirs {
        fs::create_dir_all(target_dir.join(dir)).await?;
    }

    Ok(())
}

/// Create CLAUDE.md file.
async fn create_claude_md(target_dir: &Path, name: &str) -> CwaResult<()> {
    let content = format!(
        r#"# {name}

<!-- Auto-generated by CWA. Updates sync automatically. -->

## Quick Context

**Project**: {name}
**Current Task**: None
**Active Spec**: None
**Session**: Not started

## MCP Integration

This project uses CWA MCP server. Available tools:

| Tool | Description |
|------|-------------|
| `cwa_get_current_task` | Get current in-progress task |
| `cwa_get_spec` | Get specification by ID/name |
| `cwa_get_context_summary` | Get compact project summary |
| `cwa_get_domain_model` | Get DDD domain model |
| `cwa_update_task_status` | Update task status |
| `cwa_add_decision` | Register architectural decision |
| `cwa_get_next_steps` | Get suggested next steps |
| `cwa_search_memory` | Search project memory |

## Slash Commands

- `/project:create-spec` - Create a new specification
- `/project:implement-task` - Implement the current task
- `/project:review-code` - Review code against spec
- `/project:session-summary` - Generate session summary

## Key Decisions

_No decisions recorded yet._

## Domain Glossary

_No terms defined yet._

---
_Generated by CWA v{version}_
"#,
        name = name,
        version = env!("CARGO_PKG_VERSION")
    );

    fs::write(target_dir.join("CLAUDE.md"), content).await?;
    Ok(())
}

/// Create .mcp.json configuration.
async fn create_mcp_json(target_dir: &Path) -> CwaResult<()> {
    let content = serde_json::json!({
        "mcpServers": {
            "cwa": {
                "command": "cwa",
                "args": ["mcp", "stdio"],
                "env": {}
            }
        }
    });

    let json = serde_json::to_string_pretty(&content)?;
    fs::write(target_dir.join(".mcp.json"), json).await?;
    Ok(())
}

/// Create constitution template.
async fn create_constitution(target_dir: &Path, name: &str) -> CwaResult<()> {
    let content = format!(
        r#"# {name} Constitution

## Purpose

_Define the core purpose and vision of this project._

## Core Values

1. **Clarity** - Code should be self-documenting and easy to understand
2. **Simplicity** - Prefer simple solutions over complex ones
3. **Testability** - All features must be testable

## Technical Constraints

- **Language**: _Define primary language_
- **Framework**: _Define framework if applicable_
- **Database**: _Define database technology_
- **Minimum Test Coverage**: 80%

## Quality Standards

- All code must pass linting without warnings
- No hardcoded secrets or credentials
- Documentation required for public APIs
- Meaningful commit messages

## Workflow Rules

- Only one task in progress at a time (WIP limit: 1)
- Specs must have acceptance criteria before implementation
- All architectural decisions must be recorded as ADRs
- Code review required before merging

## Out of Scope

_List things this project will NOT do._

---
_Edit this file to define your project's guiding principles._
_This document should rarely change once established._
"#,
        name = name
    );

    fs::write(target_dir.join(".cwa/constitution.md"), content).await?;
    Ok(())
}

/// Create agent templates.
async fn create_agent_templates(target_dir: &Path) -> CwaResult<()> {
    let agents_dir = target_dir.join(".claude/agents");

    // Analyst agent
    let analyst = r#"---
name: analyst
description: Analyzes requirements, market, and competition
tools: Read, WebFetch, WebSearch
---

You are a Requirements Analyst. Your role is to:

1. Research and analyze market conditions
2. Identify competitor features and strategies
3. Gather and clarify requirements
4. Document findings in structured format

## Output Format
- Use markdown for all documentation
- Include sources for market research
- Prioritize findings by importance
"#;
    fs::write(agents_dir.join("analyst.md"), analyst).await?;

    // Architect agent
    let architect = r#"---
name: architect
description: Makes architectural decisions using DDD principles
tools: Read, Glob, Grep
---

You are a Software Architect following Domain-Driven Design. Your role is to:

1. Identify bounded contexts and domain objects
2. Define context relationships (context mapping)
3. Make and document architectural decisions
4. Ensure alignment with project constitution

## Key Principles
- Favor composition over inheritance
- Keep bounded contexts loosely coupled
- Use ubiquitous language consistently
"#;
    fs::write(agents_dir.join("architect.md"), architect).await?;

    // Specifier agent
    let specifier = r#"---
name: specifier
description: Creates detailed specifications following SDD
tools: Read, Write
---

You are a Specification Engineer following Spec Driven Development. Your role is to:

1. Transform requirements into detailed specs
2. Define acceptance criteria (Given/When/Then)
3. Break specs into atomic, implementable tasks
4. Ensure specs are testable and complete

## Spec Template
- Overview (1 paragraph)
- User Stories (As a... I want... So that...)
- Acceptance Criteria (Given/When/Then)
- Tasks (atomic, ordered, max 2h each)
- Dependencies
- Out of Scope
"#;
    fs::write(agents_dir.join("specifier.md"), specifier).await?;

    // Implementer agent
    let implementer = r#"---
name: implementer
description: Implements code following specs and patterns
tools: Read, Write, Edit, Bash
---

You are a Software Developer. Your role is to:

1. Implement tasks according to specifications
2. Write tests before implementation (TDD)
3. Follow established patterns and conventions
4. Keep code simple and readable

## Implementation Rules
- Read spec before starting
- Write failing test first
- Implement minimum to pass test
- Refactor if needed
- Commit after each logical change
"#;
    fs::write(agents_dir.join("implementer.md"), implementer).await?;

    // Reviewer agent
    let reviewer = r#"---
name: reviewer
description: Reviews code against specs and standards
tools: Read, Grep, Glob
---

You are a Code Reviewer. Your role is to:

1. Verify implementation matches specification
2. Check code quality and patterns
3. Identify potential issues or improvements
4. Ensure tests are adequate

## Review Checklist
- [ ] Meets all acceptance criteria
- [ ] Tests cover happy path and edge cases
- [ ] Follows project conventions
- [ ] No security vulnerabilities
- [ ] Documentation is adequate
"#;
    fs::write(agents_dir.join("reviewer.md"), reviewer).await?;

    // Orchestrator agent
    let orchestrator = r#"---
name: orchestrator
description: Coordinates workflow across agents and manages task lifecycle
tools: Read, Bash, Glob, Grep
---

You are a Workflow Orchestrator. Your role is to:

1. Coordinate the full development lifecycle (spec → tasks → implement → review → done)
2. Delegate work to specialized agents (analyst, architect, specifier, implementer, reviewer)
3. Enforce WIP limits and workflow rules
4. Keep project context synchronized

## Workflow Steps

1. **Understand** - Use `cwa context status` to assess current state
2. **Plan** - Identify which agent should handle the current need
3. **Delegate** - Invoke the appropriate agent with clear instructions
4. **Verify** - Check outputs against acceptance criteria
5. **Advance** - Move tasks through the Kanban workflow

## Rules
- Never skip the spec phase for non-trivial features
- Ensure only 1 task is in_progress at a time
- Record architectural decisions as they emerge
- Sync CLAUDE.md after significant changes
- Always check `cwa task wip` before moving tasks
"#;
    fs::write(agents_dir.join("orchestrator.md"), orchestrator).await?;

    // Tester agent
    let tester = r#"---
name: tester
description: Generates tests from acceptance criteria (TDD/BDD)
tools: Read, Write, Edit, Bash
---

You are a Test Engineer following TDD/BDD practices. Your role is to:

1. Read acceptance criteria from specifications
2. Generate test cases BEFORE implementation
3. Write integration tests for critical paths
4. Ensure edge cases and error conditions are covered

## Process

1. **Read spec**: `cwa spec status <spec>` to get acceptance criteria
2. **Design tests**: Convert Given/When/Then into test structure
3. **Write tests**: Create failing tests first
4. **Verify coverage**: Ensure all criteria have corresponding tests

## Test Structure
```
tests/
├── unit/           # Fast, isolated tests
├── integration/    # Cross-module tests
└── acceptance/     # Spec-driven tests (1:1 with criteria)
```

## Rules
- One test per acceptance criterion minimum
- Test names describe behavior, not implementation
- Mock external dependencies, never internal logic
- Integration tests use real database (in-memory SQLite)
"#;
    fs::write(agents_dir.join("tester.md"), tester).await?;

    // Documenter agent
    let documenter = r#"---
name: documenter
description: Maintains documentation, ADRs, and CLAUDE.md synchronization
tools: Read, Write, Edit, Bash
---

You are a Documentation Engineer. Your role is to:

1. Keep CLAUDE.md synchronized with project state
2. Write and maintain Architectural Decision Records (ADRs)
3. Document public APIs and domain concepts
4. Update the domain glossary as new terms emerge

## ADR Format

```markdown
# ADR-NNN: Title

## Status
Proposed | Accepted | Deprecated | Superseded

## Context
What is the issue we're seeing that motivates this decision?

## Decision
What is the change we're proposing?

## Consequences
What becomes easier or harder as a result?
```

## When to Document
- New bounded context discovered → update domain model
- Architecture decision made → create ADR via `cwa memory add`
- New domain term used → add to glossary
- Spec completed → run `cwa codegen claude-md`

## Rules
- Documentation lives next to the code it describes
- Prefer examples over abstract explanations
- Keep CLAUDE.md under token budget (check with `cwa tokens analyze`)
- Use ubiquitous language from the domain glossary
"#;
    fs::write(agents_dir.join("documenter.md"), documenter).await?;

    Ok(())
}

/// Create command templates.
async fn create_command_templates(target_dir: &Path) -> CwaResult<()> {
    let commands_dir = target_dir.join(".claude/commands");

    // Create spec command
    let create_spec = r#"# Create Specification

Use the specifier agent to create a new specification.

## Steps
1. Gather requirements from user
2. Research existing code patterns
3. Create spec with acceptance criteria
4. Generate tasks from spec
5. Add to Kanban backlog

## Output
- New spec file in .cwa/specs/
- Tasks added to database
- CLAUDE.md updated
"#;
    fs::write(commands_dir.join("create-spec.md"), create_spec).await?;

    // Implement task command
    let implement_task = r#"# Implement Task

Implement the current task following the specification.

## Pre-Implementation
1. `cwa_get_current_task()` - Load task details
2. `cwa_get_spec(task.spec_id)` - Load specification
3. Read relevant code files

## Implementation Rules
- Follow TDD: test first, then implement
- Keep changes focused on task scope
- Commit after each logical change

## Post-Implementation
1. Run all tests
2. `cwa_update_task_status(task_id, 'review')`
3. Record any decisions made
"#;
    fs::write(commands_dir.join("implement-task.md"), implement_task).await?;

    // Session summary command
    let session_summary = r#"# Session Summary

Generate a summary of the current development session.

## Include
- Tasks completed
- Decisions made
- Blockers encountered
- Insights gained
- Suggested next steps

## Output
- Update session record
- Add key insights to memory
- Refresh CLAUDE.md
"#;
    fs::write(commands_dir.join("session-summary.md"), session_summary).await?;

    // Next task command
    let next_task = r#"# Next Task

Pick the next task from the backlog and start working on it.

## Steps
1. Check WIP limits: `cwa task wip`
2. If in_progress is at limit, finish current task first
3. Pick highest priority task from `todo` column
4. Move it to `in_progress`: `cwa task move <id> in_progress`
5. Load the associated spec: `cwa spec status <spec>`
6. Begin implementation following the spec

## Pre-conditions
- No task currently in_progress (WIP limit: 1)
- Task must be in `todo` column
- Associated spec must have acceptance criteria
"#;
    fs::write(commands_dir.join("next-task.md"), next_task).await?;

    // Review code command
    let review_code = r#"# Review Code

Review the current changes against the specification's acceptance criteria.

## Steps
1. Get current task: `cwa_get_current_task()`
2. Load spec: `cwa_get_spec(task.spec_id)`
3. Read changed files (git diff)
4. For each acceptance criterion:
   - Verify implementation exists
   - Check test coverage
   - Mark as pass/fail
5. If all pass: `cwa task move <id> review`
6. If issues found: list them and keep in_progress

## Checklist
- [ ] All acceptance criteria met
- [ ] Tests pass
- [ ] No new warnings or lint issues
- [ ] No hardcoded values or secrets
- [ ] Error handling is appropriate
"#;
    fs::write(commands_dir.join("review-code.md"), review_code).await?;

    // Domain discover command
    let domain_discover = r#"# Domain Discovery

Interactive workflow for discovering domain concepts in your project.

## Steps
1. Ask about the core business problem
2. Identify key actors and roles
3. Map out main business processes
4. Extract nouns → potential entities/value objects
5. Extract verbs → potential commands/events
6. Group related concepts → bounded contexts
7. Define relationships between contexts

## Output
- Create bounded contexts: `cwa domain context new <name>`
- Add to glossary
- Record in knowledge graph: `cwa graph sync`
- Add key insights to memory: `cwa memory add`

## Questions to Ask
- What is the core business value?
- Who are the main actors?
- What are the key business processes?
- Where do different teams/concerns diverge? (context boundaries)
- What terms mean different things in different contexts?
"#;
    fs::write(commands_dir.join("domain-discover.md"), domain_discover).await?;

    // Sync context command
    let sync_context = r#"# Sync Context

Regenerate all Claude Code artifacts and synchronize the knowledge graph.

## Steps
1. Regenerate CLAUDE.md: `cwa codegen claude-md`
2. Regenerate agents: `cwa codegen agent --all`
3. Regenerate hooks: `cwa codegen hooks`
4. Sync knowledge graph: `cwa graph sync`
5. Sync memory: `cwa memory sync`
6. Report token usage: `cwa tokens report`

## When to Run
- After creating new bounded contexts
- After defining new specs
- After recording important decisions
- At the start of each development session
- After completing a major feature
"#;
    fs::write(commands_dir.join("sync-context.md"), sync_context).await?;

    // Status command
    let status = r#"# Project Status

Display a comprehensive overview of the current project state.

## Information to Gather
1. `cwa context status` — Active spec, current task, session info
2. `cwa task board` — Kanban board state
3. `cwa task wip` — WIP limit status
4. `cwa spec list` — All specifications and their states
5. `cwa graph status` — Knowledge graph statistics
6. `cwa tokens analyze --all` — Token budget usage

## Output Format
Present a concise summary:
- Current focus (active spec + in_progress task)
- Blockers or issues
- Progress metrics (done/total tasks)
- Suggested next action
"#;
    fs::write(commands_dir.join("status.md"), status).await?;

    // Generate tasks command
    let generate_tasks = r#"# /generate-tasks

Generate tasks from a specification's acceptance criteria.

## Usage

```
/generate-tasks <spec-id>
```

## Steps

1. Get the spec details using MCP tool `cwa_get_spec` with the provided spec ID
2. Analyze each acceptance criterion in the spec
3. For each criterion, create a task using MCP tool `cwa_create_task`:
   - Title: Based on the criterion
   - Description: Include the criterion text and any context
   - Link to the spec ID
4. Report the created tasks to the user

## Example

```
/generate-tasks spec-123
```

This will create individual tasks from spec-123's acceptance criteria.

## Notes

- Each acceptance criterion becomes one task
- Tasks are created in "backlog" status
- Use `cwa task board` to see the created tasks
"#;
    fs::write(commands_dir.join("generate-tasks.md"), generate_tasks).await?;

    // Run backlog command
    let run_backlog = r#"# /run-backlog

Plan and execute all tasks in the backlog.

## Usage

```
/run-backlog [--dry-run]
```

## Steps

1. Get the current board state using MCP tool `cwa_get_context_summary`
2. List all tasks with status "backlog" or "todo"
3. For each task in priority order:
   a. Move the task to "in_progress" using `cwa_update_task_status`
   b. Get task details with `cwa_get_current_task`
   c. Plan the implementation approach
   d. Execute the implementation
   e. Verify the task is complete
   f. Move to "review" then "done" as appropriate
4. Report progress after each task

## Options

- `--dry-run`: Only show which tasks would be executed without making changes

## Notes

- Respects WIP limits (only 1 task in_progress at a time)
- Will pause and ask for input if blocked or uncertain
- Uses the project's domain model and specs for context
- Commits changes after each completed task
"#;
    fs::write(commands_dir.join("run-backlog.md"), run_backlog).await?;

    Ok(())
}

/// Create rule templates.
async fn create_rule_templates(target_dir: &Path) -> CwaResult<()> {
    let rules_dir = target_dir.join(".claude/rules");

    // API rules
    let api_rules = r#"# API Code Rules

These rules apply when working on API-related code.

## Patterns
- Use RESTful conventions
- Validate all input at boundaries
- Return consistent error formats
- Include request ID in responses

## Security
- Never trust client input
- Use parameterized queries
- Implement rate limiting
- Log security-relevant events
"#;
    fs::write(rules_dir.join("api.md"), api_rules).await?;

    // Domain rules
    let domain_rules = r#"# Domain Code Rules

These rules apply when working on domain/business logic.

## DDD Principles
- Keep domain logic in domain layer
- Use ubiquitous language
- Aggregates enforce invariants
- Domain events for side effects

## Patterns
- Entities have identity
- Value objects are immutable
- Services for cross-aggregate operations
"#;
    fs::write(rules_dir.join("domain.md"), domain_rules).await?;

    // Test rules
    let test_rules = r#"# Test Code Rules

These rules apply when writing tests.

## Structure
- Arrange, Act, Assert pattern
- One assertion per test (generally)
- Descriptive test names

## Coverage
- Test happy paths
- Test edge cases
- Test error conditions
- Integration tests for critical paths
"#;
    fs::write(rules_dir.join("tests.md"), test_rules).await?;

    // Workflow rules
    let workflow_rules = r#"# Workflow Rules

These rules enforce the CWA development workflow.

## Spec Before Code
- Every non-trivial feature requires a specification
- Specs must have acceptance criteria before implementation begins
- Use `cwa spec validate` to check completeness

## Kanban Discipline
- Only 1 task in_progress at a time (WIP limit enforced)
- Tasks flow: backlog → todo → in_progress → review → done
- Never skip the review step
- Check WIP with `cwa task wip` before moving tasks

## Decision Tracking
- Record architectural decisions as they are made
- Use `cwa memory add "<decision>" --type decision`
- Decisions should include rationale (the "why")
- Review past decisions before making conflicting ones

## Context Sync
- Run `cwa codegen claude-md` after significant changes
- Keep token budget below limits (`cwa tokens optimize`)
- Sync graph after new entities: `cwa graph sync`
"#;
    fs::write(rules_dir.join("workflow.md"), workflow_rules).await?;

    // Memory rules
    let memory_rules = r#"# Memory Rules

When and how to record project memory.

## What to Record

### Decisions (--type decision)
- Technology choices and trade-offs
- Architecture patterns adopted
- Libraries chosen (and alternatives rejected)
- API design decisions

### Facts (--type fact)
- External API behaviors discovered
- Performance characteristics measured
- Environment-specific behaviors
- Integration quirks

### Preferences (--type preference)
- Code style preferences
- Naming conventions agreed upon
- Team workflow preferences
- Tool configuration choices

### Patterns (--type pattern)
- Recurring code patterns in the project
- Error handling approaches
- Testing strategies that work well
- Deployment procedures

## When to Record
- After making a non-obvious technical choice
- When discovering unexpected behavior
- When a team member states a preference
- After resolving a difficult bug (root cause)
- When establishing a new pattern

## Rules
- Keep entries concise (1-2 sentences)
- Include context ("for X, we do Y because Z")
- Use `cwa memory search` before adding duplicates
- Periodically compact: `cwa memory compact`
"#;
    fs::write(rules_dir.join("memory.md"), memory_rules).await?;

    Ok(())
}

/// Create initial skill templates.
async fn create_skill_templates(target_dir: &Path) -> CwaResult<()> {
    let skills_dir = target_dir.join(".claude/skills");

    // Workflow kickoff skill
    let workflow_kickoff = r#"# Workflow Kickoff

Start a new feature workflow from a high-level description.

## What This Skill Does

Takes a feature idea and drives it through the full CWA workflow:
1. Creates a specification with acceptance criteria
2. Breaks the spec into atomic tasks
3. Sets up the Kanban board
4. Generates Claude Code artifacts

## Usage

Provide a feature description and this skill will:

### Step 1: Specification
- Create spec: `cwa spec new "<title>" --description "<desc>" --priority <p>`
- Define acceptance criteria (Given/When/Then format)

### Step 2: Task Breakdown
- Create tasks from the spec's acceptance criteria
- Each task should be completable in under 2 hours
- Link tasks to the spec

### Step 3: Board Setup
- Move tasks to `todo` column
- Respect WIP limits

### Step 4: Artifact Generation
- Generate agent if new bounded context: `cwa codegen agent`
- Generate skill from spec: `cwa codegen skill <spec-id>`
- Update CLAUDE.md: `cwa codegen claude-md`

## Input
A natural language description of the feature to implement.

## Output
- Spec created with acceptance criteria
- Tasks on the Kanban board
- Claude Code artifacts generated
- Ready to start implementation
"#;
    fs::write(skills_dir.join("workflow-kickoff/SKILL.md"), workflow_kickoff).await?;

    // Refactor safe skill
    let refactor_safe = r#"# Safe Refactoring

Perform a refactoring with test safety net.

## What This Skill Does

Guides a safe refactoring process:
1. Ensures tests exist and pass before changes
2. Performs the refactoring in small, verified steps
3. Verifies tests still pass after each step

## Process

### Pre-Refactor
1. Identify the code to refactor
2. Run existing tests: verify they pass
3. If no tests exist: write characterization tests first
4. Record the refactoring decision: `cwa memory add "<what and why>" --type decision`

### During Refactor
1. Make one small change at a time
2. Run tests after each change
3. If tests fail: revert the last change
4. Commit after each successful step

### Post-Refactor
1. Run full test suite
2. Check for any new warnings
3. Update documentation if APIs changed
4. Move task to review: `cwa task move <id> review`

## Rules
- Never refactor and add features simultaneously
- Keep commits atomic (one logical change each)
- If tests don't exist, write them first (separate commit)
- Preserve all existing behavior unless explicitly changing it
"#;
    fs::write(skills_dir.join("refactor-safe/SKILL.md"), refactor_safe).await?;

    Ok(())
}

/// Create initial hooks.json.
async fn create_hooks_json(target_dir: &Path) -> CwaResult<()> {
    let hooks = serde_json::json!({
        "hooks": [
            {
                "event": "pre-tool-call",
                "tool": "Write",
                "command": "echo '[CWA] Remember: check test coverage for new/modified files'",
                "description": "Remind about test coverage when writing files"
            },
            {
                "event": "pre-tool-call",
                "tool": "Bash(git commit*)",
                "command": "cwa task wip 2>/dev/null || true",
                "description": "Check WIP limits before committing"
            },
            {
                "event": "post-tool-call",
                "tool": "Bash(cargo test*)",
                "command": "echo '[CWA] Tests completed. Update task status if all pass: cwa task move <id> review'",
                "description": "Remind to advance task after tests pass"
            }
        ]
    });

    let json = serde_json::to_string_pretty(&hooks)?;
    fs::write(target_dir.join(".claude/hooks.json"), json).await?;
    Ok(())
}

/// Create Docker infrastructure files.
async fn create_docker_infrastructure(target_dir: &Path) -> CwaResult<()> {
    let docker_dir = target_dir.join(".cwa/docker");
    let scripts_dir = docker_dir.join("scripts");

    // Docker Compose for CWA infrastructure (Neo4j, Qdrant, Ollama)
    let docker_compose = r#"# CWA Infrastructure - Knowledge Graph + Semantic Memory
# Start with: docker compose -f .cwa/docker/docker-compose.yml up -d

services:
  neo4j:
    image: neo4j:5.26-community
    container_name: cwa-neo4j
    environment:
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD:-cwa_dev_2026}
      - NEO4J_PLUGINS=["apoc"]
      - NEO4J_apoc_export_file_enabled=true
      - NEO4J_apoc_import_file_enabled=true
      - NEO4J_apoc_import_file_use__neo4j__config=true
    ports:
      - "${NEO4J_HTTP_PORT:-7474}:7474"
      - "${NEO4J_BOLT_PORT:-7687}:7687"
    volumes:
      - neo4j-data:/data
      - neo4j-logs:/logs
    networks:
      - cwa-network
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:7474"]
      interval: 10s
      timeout: 5s
      retries: 5

  qdrant:
    image: qdrant/qdrant:v1.13.2
    container_name: cwa-qdrant
    ports:
      - "${QDRANT_HTTP_PORT:-6333}:6333"
      - "${QDRANT_GRPC_PORT:-6334}:6334"
    volumes:
      - qdrant-data:/qdrant/storage
    networks:
      - cwa-network
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:6333/healthz"]
      interval: 10s
      timeout: 5s
      retries: 5

  ollama:
    image: ollama/ollama:0.5.4
    container_name: cwa-ollama
    ports:
      - "${OLLAMA_PORT:-11434}:11434"
    volumes:
      - ollama-data:/root/.ollama
    networks:
      - cwa-network
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:11434/api/tags"]
      interval: 10s
      timeout: 5s
      retries: 5

networks:
  cwa-network:
    driver: bridge

volumes:
  neo4j-data:
  neo4j-logs:
  qdrant-data:
  ollama-data:
"#;
    fs::write(docker_dir.join("docker-compose.yml"), docker_compose).await?;

    // Environment template
    let env_example = r#"# CWA Infrastructure Configuration
NEO4J_PASSWORD=cwa_dev_2026
NEO4J_HTTP_PORT=7474
NEO4J_BOLT_PORT=7687
QDRANT_HTTP_PORT=6333
QDRANT_GRPC_PORT=6334
OLLAMA_PORT=11434
OLLAMA_MODEL=nomic-embed-text
"#;
    fs::write(docker_dir.join(".env.example"), env_example).await?;

    // Qdrant initialization script
    let init_qdrant = r#"#!/bin/bash
# Initialize Qdrant collections for CWA

QDRANT_URL="${QDRANT_URL:-http://localhost:6333}"

echo "Creating CWA Qdrant collections..."

# Create memories collection (768 dims for nomic-embed-text)
curl -s -X PUT "${QDRANT_URL}/collections/cwa_memories" \
  -H "Content-Type: application/json" \
  -d '{
    "vectors": { "size": 768, "distance": "Cosine" }
  }' && echo " - cwa_memories: created"

# Create terms collection for glossary embeddings
curl -s -X PUT "${QDRANT_URL}/collections/cwa_terms" \
  -H "Content-Type: application/json" \
  -d '{
    "vectors": { "size": 768, "distance": "Cosine" }
  }' && echo " - cwa_terms: created"

echo "Done."
"#;
    fs::write(scripts_dir.join("init-qdrant.sh"), init_qdrant).await?;

    // Neo4j initialization script
    let init_neo4j = r#"// CWA Knowledge Graph Schema
// Run with: cat init-neo4j.cypher | cypher-shell -u neo4j -p <password>

// Uniqueness constraints
CREATE CONSTRAINT spec_id IF NOT EXISTS FOR (s:Spec) REQUIRE s.id IS UNIQUE;
CREATE CONSTRAINT task_id IF NOT EXISTS FOR (t:Task) REQUIRE t.id IS UNIQUE;
CREATE CONSTRAINT context_id IF NOT EXISTS FOR (c:BoundedContext) REQUIRE c.id IS UNIQUE;
CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:DomainEntity) REQUIRE e.id IS UNIQUE;
CREATE CONSTRAINT decision_id IF NOT EXISTS FOR (d:Decision) REQUIRE d.id IS UNIQUE;
CREATE CONSTRAINT memory_id IF NOT EXISTS FOR (m:Memory) REQUIRE m.id IS UNIQUE;
CREATE CONSTRAINT term_id IF NOT EXISTS FOR (t:GlossaryTerm) REQUIRE t.id IS UNIQUE;
CREATE CONSTRAINT observation_id IF NOT EXISTS FOR (o:Observation) REQUIRE o.id IS UNIQUE;

// Full-text search indexes
CREATE FULLTEXT INDEX spec_search IF NOT EXISTS FOR (s:Spec) ON EACH [s.title, s.description];
CREATE FULLTEXT INDEX task_search IF NOT EXISTS FOR (t:Task) ON EACH [t.title, t.description];
CREATE FULLTEXT INDEX memory_search IF NOT EXISTS FOR (m:Memory) ON EACH [m.content];
"#;
    fs::write(scripts_dir.join("init-neo4j.cypher"), init_neo4j).await?;

    // Make init-qdrant.sh executable on Unix
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let script_path = scripts_dir.join("init-qdrant.sh");
        let mut perms = tokio::fs::metadata(&script_path).await?.permissions();
        perms.set_mode(0o755);
        tokio::fs::set_permissions(&script_path, perms).await?;
    }

    Ok(())
}

/// Generate initial project from a prompt (placeholder).
pub async fn generate_from_prompt(_target_dir: &Path, _prompt: &str) -> CwaResult<()> {
    // This would use Claude to generate initial spec from prompt
    // For now, it's a placeholder
    tracing::info!("Prompt-based generation not yet implemented");
    Ok(())
}
