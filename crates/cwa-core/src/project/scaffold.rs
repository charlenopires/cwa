//! Project scaffolding (directory and file generation).

use crate::error::CwaResult;
use crate::task;
use std::path::Path;
use tokio::fs;

/// Create a new CWA project with full directory structure.
pub async fn create_project(target_dir: &Path, name: &str) -> CwaResult<()> {
    // Create directory structure
    create_directories(target_dir).await?;

    // Create initial files
    create_claude_md(target_dir, name).await?;
    create_mcp_json(target_dir).await?;
    create_constitution(target_dir, name).await?;
    create_agent_templates(target_dir).await?;
    create_command_templates(target_dir).await?;
    create_rule_templates(target_dir).await?;

    // Initialize database
    let db_path = target_dir.join(".cwa/cwa.db");
    let pool = cwa_db::init_pool(&db_path)?;

    // Create project record
    let project = crate::project::create_project(&pool, name, None)?;

    // Update constitution path
    let constitution_path = target_dir.join(".cwa/constitution.md");
    crate::project::set_constitution_path(&pool, &project.id, constitution_path.to_str().unwrap())?;

    // Initialize Kanban columns
    task::init_kanban_columns(&pool, &project.id)?;

    Ok(())
}

/// Create all required directories.
async fn create_directories(target_dir: &Path) -> CwaResult<()> {
    let dirs = [
        ".cwa",
        ".cwa/specs",
        ".cwa/domain",
        ".cwa/decisions",
        ".cwa/analyses",
        ".cwa/sessions",
        ".claude",
        ".claude/agents",
        ".claude/commands",
        ".claude/rules",
        "docs",
    ];

    for dir in dirs {
        fs::create_dir_all(target_dir.join(dir)).await?;
    }

    Ok(())
}

/// Create CLAUDE.md file.
async fn create_claude_md(target_dir: &Path, name: &str) -> CwaResult<()> {
    let content = format!(
        r#"# {name}

<!-- Auto-generated by CWA. Updates sync automatically. -->

## Quick Context

**Project**: {name}
**Current Task**: None
**Active Spec**: None
**Session**: Not started

## MCP Integration

This project uses CWA MCP server. Available tools:

| Tool | Description |
|------|-------------|
| `cwa_get_current_task` | Get current in-progress task |
| `cwa_get_spec` | Get specification by ID/name |
| `cwa_get_context_summary` | Get compact project summary |
| `cwa_get_domain_model` | Get DDD domain model |
| `cwa_update_task_status` | Update task status |
| `cwa_add_decision` | Register architectural decision |
| `cwa_get_next_steps` | Get suggested next steps |
| `cwa_search_memory` | Search project memory |

## Slash Commands

- `/project:create-spec` - Create a new specification
- `/project:implement-task` - Implement the current task
- `/project:review-code` - Review code against spec
- `/project:session-summary` - Generate session summary

## Key Decisions

_No decisions recorded yet._

## Domain Glossary

_No terms defined yet._

---
_Generated by CWA v{version}_
"#,
        name = name,
        version = env!("CARGO_PKG_VERSION")
    );

    fs::write(target_dir.join("CLAUDE.md"), content).await?;
    Ok(())
}

/// Create .mcp.json configuration.
async fn create_mcp_json(target_dir: &Path) -> CwaResult<()> {
    let content = serde_json::json!({
        "mcpServers": {
            "cwa": {
                "command": "cwa",
                "args": ["mcp", "stdio"],
                "env": {}
            }
        }
    });

    let json = serde_json::to_string_pretty(&content)?;
    fs::write(target_dir.join(".mcp.json"), json).await?;
    Ok(())
}

/// Create constitution template.
async fn create_constitution(target_dir: &Path, name: &str) -> CwaResult<()> {
    let content = format!(
        r#"# {name} Constitution

## Purpose

_Define the core purpose and vision of this project._

## Core Values

1. **Clarity** - Code should be self-documenting and easy to understand
2. **Simplicity** - Prefer simple solutions over complex ones
3. **Testability** - All features must be testable

## Technical Constraints

- **Language**: _Define primary language_
- **Framework**: _Define framework if applicable_
- **Database**: _Define database technology_
- **Minimum Test Coverage**: 80%

## Quality Standards

- All code must pass linting without warnings
- No hardcoded secrets or credentials
- Documentation required for public APIs
- Meaningful commit messages

## Workflow Rules

- Only one task in progress at a time (WIP limit: 1)
- Specs must have acceptance criteria before implementation
- All architectural decisions must be recorded as ADRs
- Code review required before merging

## Out of Scope

_List things this project will NOT do._

---
_Edit this file to define your project's guiding principles._
_This document should rarely change once established._
"#,
        name = name
    );

    fs::write(target_dir.join(".cwa/constitution.md"), content).await?;
    Ok(())
}

/// Create agent templates.
async fn create_agent_templates(target_dir: &Path) -> CwaResult<()> {
    let agents_dir = target_dir.join(".claude/agents");

    // Analyst agent
    let analyst = r#"---
name: analyst
description: Analyzes requirements, market, and competition
tools: Read, WebFetch, WebSearch
---

You are a Requirements Analyst. Your role is to:

1. Research and analyze market conditions
2. Identify competitor features and strategies
3. Gather and clarify requirements
4. Document findings in structured format

## Output Format
- Use markdown for all documentation
- Include sources for market research
- Prioritize findings by importance
"#;
    fs::write(agents_dir.join("analyst.md"), analyst).await?;

    // Architect agent
    let architect = r#"---
name: architect
description: Makes architectural decisions using DDD principles
tools: Read, Glob, Grep
---

You are a Software Architect following Domain-Driven Design. Your role is to:

1. Identify bounded contexts and domain objects
2. Define context relationships (context mapping)
3. Make and document architectural decisions
4. Ensure alignment with project constitution

## Key Principles
- Favor composition over inheritance
- Keep bounded contexts loosely coupled
- Use ubiquitous language consistently
"#;
    fs::write(agents_dir.join("architect.md"), architect).await?;

    // Specifier agent
    let specifier = r#"---
name: specifier
description: Creates detailed specifications following SDD
tools: Read, Write
---

You are a Specification Engineer following Spec Driven Development. Your role is to:

1. Transform requirements into detailed specs
2. Define acceptance criteria (Given/When/Then)
3. Break specs into atomic, implementable tasks
4. Ensure specs are testable and complete

## Spec Template
- Overview (1 paragraph)
- User Stories (As a... I want... So that...)
- Acceptance Criteria (Given/When/Then)
- Tasks (atomic, ordered, max 2h each)
- Dependencies
- Out of Scope
"#;
    fs::write(agents_dir.join("specifier.md"), specifier).await?;

    // Implementer agent
    let implementer = r#"---
name: implementer
description: Implements code following specs and patterns
tools: Read, Write, Edit, Bash
---

You are a Software Developer. Your role is to:

1. Implement tasks according to specifications
2. Write tests before implementation (TDD)
3. Follow established patterns and conventions
4. Keep code simple and readable

## Implementation Rules
- Read spec before starting
- Write failing test first
- Implement minimum to pass test
- Refactor if needed
- Commit after each logical change
"#;
    fs::write(agents_dir.join("implementer.md"), implementer).await?;

    // Reviewer agent
    let reviewer = r#"---
name: reviewer
description: Reviews code against specs and standards
tools: Read, Grep, Glob
---

You are a Code Reviewer. Your role is to:

1. Verify implementation matches specification
2. Check code quality and patterns
3. Identify potential issues or improvements
4. Ensure tests are adequate

## Review Checklist
- [ ] Meets all acceptance criteria
- [ ] Tests cover happy path and edge cases
- [ ] Follows project conventions
- [ ] No security vulnerabilities
- [ ] Documentation is adequate
"#;
    fs::write(agents_dir.join("reviewer.md"), reviewer).await?;

    Ok(())
}

/// Create command templates.
async fn create_command_templates(target_dir: &Path) -> CwaResult<()> {
    let commands_dir = target_dir.join(".claude/commands");

    // Create spec command
    let create_spec = r#"# Create Specification

Use the specifier agent to create a new specification.

## Steps
1. Gather requirements from user
2. Research existing code patterns
3. Create spec with acceptance criteria
4. Generate tasks from spec
5. Add to Kanban backlog

## Output
- New spec file in .cwa/specs/
- Tasks added to database
- CLAUDE.md updated
"#;
    fs::write(commands_dir.join("create-spec.md"), create_spec).await?;

    // Implement task command
    let implement_task = r#"# Implement Task

Implement the current task following the specification.

## Pre-Implementation
1. `cwa_get_current_task()` - Load task details
2. `cwa_get_spec(task.spec_id)` - Load specification
3. Read relevant code files

## Implementation Rules
- Follow TDD: test first, then implement
- Keep changes focused on task scope
- Commit after each logical change

## Post-Implementation
1. Run all tests
2. `cwa_update_task_status(task_id, 'review')`
3. Record any decisions made
"#;
    fs::write(commands_dir.join("implement-task.md"), implement_task).await?;

    // Session summary command
    let session_summary = r#"# Session Summary

Generate a summary of the current development session.

## Include
- Tasks completed
- Decisions made
- Blockers encountered
- Insights gained
- Suggested next steps

## Output
- Update session record
- Add key insights to memory
- Refresh CLAUDE.md
"#;
    fs::write(commands_dir.join("session-summary.md"), session_summary).await?;

    Ok(())
}

/// Create rule templates.
async fn create_rule_templates(target_dir: &Path) -> CwaResult<()> {
    let rules_dir = target_dir.join(".claude/rules");

    // API rules
    let api_rules = r#"# API Code Rules

These rules apply when working on API-related code.

## Patterns
- Use RESTful conventions
- Validate all input at boundaries
- Return consistent error formats
- Include request ID in responses

## Security
- Never trust client input
- Use parameterized queries
- Implement rate limiting
- Log security-relevant events
"#;
    fs::write(rules_dir.join("api.md"), api_rules).await?;

    // Domain rules
    let domain_rules = r#"# Domain Code Rules

These rules apply when working on domain/business logic.

## DDD Principles
- Keep domain logic in domain layer
- Use ubiquitous language
- Aggregates enforce invariants
- Domain events for side effects

## Patterns
- Entities have identity
- Value objects are immutable
- Services for cross-aggregate operations
"#;
    fs::write(rules_dir.join("domain.md"), domain_rules).await?;

    // Test rules
    let test_rules = r#"# Test Code Rules

These rules apply when writing tests.

## Structure
- Arrange, Act, Assert pattern
- One assertion per test (generally)
- Descriptive test names

## Coverage
- Test happy paths
- Test edge cases
- Test error conditions
- Integration tests for critical paths
"#;
    fs::write(rules_dir.join("tests.md"), test_rules).await?;

    Ok(())
}

/// Generate initial project from a prompt (placeholder).
pub async fn generate_from_prompt(_target_dir: &Path, _prompt: &str) -> CwaResult<()> {
    // This would use Claude to generate initial spec from prompt
    // For now, it's a placeholder
    tracing::info!("Prompt-based generation not yet implemented");
    Ok(())
}
